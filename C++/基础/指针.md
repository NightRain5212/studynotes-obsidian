
#  [[变量]]的地址、[[C/指针|指针]]

- 在程序中，我们的数据都有其存储的地址。地址也是数据。存放地址所用的[[变量]]类型有一个特殊的名字，叫做「[[C/指针|指针]][[变量]]」，有时也简称做「[[C/指针|指针]]」。

# [[C/指针|指针]][[变量]]的大小

- [[C/指针|指针]][[变量]]的大小在不同环境下有差异。在 32 位机上，地址用 32 位二进制整数表示，因此一个[[C/指针|指针]]的大小为 4 字节。而 64 位机上，地址用 64 位二进制整数表示，因此一个[[C/指针|指针]]的大小就变成了 8 字节。

# 具体使用

- 同C[[C/指针|指针]]
- 如果要访问指针指向的结构中的成员，需要先对指针进行解引用，再使用 `.` 成员关系运算符。不过，更推荐使用「箭头」运算符 `->` 这一更简便的写法。

# 空指针

- C++11 引入了 `nullptr` 关键字作为空指针常量。
- C++ 规定 `nullptr` 可以隐式转换为任何指针类型，这种转换结果是该类型的空指针值。`nullptr` 的类型为 `std::nullptr_t`, 称作空指针类型

# 动态实例化

- 动态内存分配：程序会在运行时，向操作系统动态地申请或归还存放数据所需的内存。当程序通过调用操作系统接口申请内存时，操作系统将返回程序所申请空间的地址。要使用这块空间，我们需要将这块空间的地址存储在指针变量中。

## 动态内存分配

- 在 C++ 中，我们使用 `new` 运算符来获取一块内存，使用 `delete` 运算符释放某指针所指向的空间。
- 「`new` 表达式」将尝试开辟一块对应大小的空间，并尝试在这块空间上构造这一对象，并返回这一空间的地址。
```
int* p = new int(1234); 
/* ... */ 
delete p;
```
- 也可以使用 `new[]` 运算符创建数组，这时 `new[]` 运算符会返回数组的首地址，也就是数组第一个元素的地址，我们可以用对应类型的指针存储这个地址。释放时，则需要使用 `delete[]` 运算符。
```cpp
size_t element_cnt = 5;
int *p = new int[element_cnt]; 
delete[] p;
```

### 动态创建二维数组

```cpp
//这种声明方式要求 N 和 M 为在编译期即可确定的常量表达式
int a[N][M];

//声明一个长度为 N × M 的一维数组，这种方法可以保证二维数组是连续的
int* a = new int[N * M];

//对于一个存放的若干数组的数组，实际上为一个存放的若干数组的首地址的数组，也就是一个存放若干指针变量的数组

//声明储存指针的数组
//这样获得的二维数组，不能保证其空间是连续的。
int** a = new int*[5];

//为每一个数组申请空间
for (int i = 0; i < 5; i++) { 
	a[i] = new int[5]; 
}

//内存的释放则需要进行一个逆向的操作：即先释放每一个数组，再释放存储这些数组首地址的数组
for (int i = 0; i < 5; i++) { 
	delete[] a[i]; 
} 
delete[] a;

//使用「指向数组的指针」
int main() { 
	int(*a)[5] = new int[5][5]; 
	int* p = a[2]; 
	a[2][1] = 1; 
	delete[] a; 
}
```
# 指向函数的指针

- 简单地说，要调用一个函数，需要知晓该函数的参数类型、个数以及返回值类型，这些也统一称作接口类型。
- 可以通过函数指针调用函数。有时候，若干个函数的接口类型是相同的，使用函数指针可以根据程序的运行 **动态地** 选择需要调用的函数。换句话说，可以在不修改一个函数的情况下，仅通过修改向其传入的参数（函数指针），使得该函数的行为发生变化。

```cpp
int (*pt) (double a);
//定义一个指向函数的指针，该函数接受一个double参数，返回int
```

# `void*`

- void* 的含义是：指向未知类型对象的指针。
- 使用`void*` 时必须显式转换为对应类型的指针。