
- 数组是按顺序储存一系列类型相同的值。
- 如：
```
float debts[20];/*声明一个含20个元素的float数组*/
```
- 数组的第一个元素是`debts[0]` ,第二个元素是`debts[1]` 
- #WARNING 数组的编号从0开始
- `scanf("%f",&debts[4]);` 把一个值读入数组的第五个元素。
- `debts[6] = 1.2e+21;` 对数组中的元素赋值。

# 初始化数组

- 只储存单个值的变量有时也称为标量变量(scalar variable)
- 数组初始化
```
int powers[8] = {1,2,4,6,8,16,32,64};
```
- 用以逗号分隔的值列表(用花括号括起来)来初始化数组，各值之间用逗号分隔。在逗号和值之间可以使用空格。
- 根据上面的初始化，把1赋给数组的首元素，以此类推.
- (不支持ANSI的编译器会把这种形式的初始化识别为语法错误，在数组声明前加上关键字 static 可解决此问题。第12章将详细讨论这个关键字)。
- 当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0。
- 也就是说，如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值。但是，如果部分初始化数组，剩余的元素就会被初始化为0。
- 如果==初始化数组时省略方括号中的数字==，编译器会根据初始化列表中的项数来确定数组的大小。

# const数组

- 有时需要把数组设置为==只读==。这样，程序只能从数组中检索值，不能把新值写入数组。要创建只读数组，应该用 const声明和初始化数组。

# 指定初始化器

- 可以初始化指定的数组元素。
```
int arr[6] = {[5] = 212}; // 把arr[5]初始化为212.
```
- 在初始化一个元素后，未初始化的元素会被设置为0。
- 如果初始化器后面有更多的值，则会被用于初始化指定元素后面的元素。
- 再次初始化指定的元素，会取代之前的初始化。

# 数组边界

- C编译器不会检查边界，必须确保下标是一个有效的值。

# 指定数组的大小

- 声明数组时在方括号内只能用整型常量表达式，且值必须大于0。

# 变长数组（VLA）

- 用变量表示数组的维度。
- 变长数组必须是自动存储类别。
- 变长数组不能改变已创建数组的大小，而是在创建数组时，用变量指定数组的维度。
- C99/C11标准规定，可以省略原型中的形参名，但是在这种情况下，必须用星号来代替省略的维度。
```
int sum2d(int,int,int ar[*][*]);
```
- 变长数组还允许动态内存分配，这说明可以在程序运行时指定数组的大小。普通数组都是静态内存分配，即在编译时确定数组的大小。由于数组大小是常量，所以编译器在编译时就知道了。

```
int n = 5;
float a[n];   //变长数组
```



# 多维数组

```
float rain[5][12];
//内含5个数组作为数组的元素，每个数组元素含12个float类型的元素。
```
- `rain[0]` 到`rain[4]` 是数组，每个数组包含12个元素。
- `rain[0][0]`  到 `rain[0][11]` 是元素。

# 初始化二维数组

- 初始化二维数组建立在初始化一维数组的基础上。
- 先初始化一维数组
```
sometype arl[5] = {val1,val2,val3,val4,val5}
```
- 这里的val1等表示sometype类型的值。
- 如果 sometype是一个内含12个double元素的数组，那么val1就是由2个double元素组成的数组。
- 初始化二维数组。
```
const float rain[YEARS][MONTHS] =
{
	{4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6},
	{8.5,8.2,1.2,1.6,2.4,0.05.2,0.9,0.3,0.9,1.4,7.3},
	{19.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4},
	{17.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2},
	{7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2}
}
```

# 指针与数组

- 我们的系统中，==地址按字节编址==，short 类型占用2字节，double类型占用8字节。
- 在C中，指针加1指的是增加一个存储单元。
- 对数组而言，这意味着把==加1后的地址是下一个元素的地址==，而不是下一个字节的地址。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节.
- (即使指针指向的是标量变量，也要知道变量的类型，否则`*pt` 就无法正确地取回地址上的值)。
- ==数组名是数组首元素的地址==
- 定义`ar[n]` 实际上就是`*(ar + n)` ,即为到内存的ar位置，移动n个单元检索储存在那里的值。
```
short dates[4];
*dates + 2      //dates第一个元素的值加2。
*(dates + 2)    //dates第三个元素的值。
```

# 函数，数组与指针

- 声明数组形参。因为==数组名是数组首元素的地址==，作为实参的数组名，要求形参是一个与之匹配的指针。只有在这种情况下，C才会`int ar[]` 与`int * ar` 才会解释成一样。
- 只有在函数原型与函数定义头中，才能用`int ar[]` 代替`int * ar`  。
- 函数处理数组必须知道何时开始，何时结束。
- "有效越界"：C保证再给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。
- `*` 与 `++` 的优先级相同
```
total += *start++;
//start++先求值，然后才是*start.
//先将指针指向位置的值加到total上，再递增指针。
//*++start 则相反。
```

# 指针表示法与数组表示法

- 处理数组的函数实际上用[[C/指针|指针]]作为参数，但是在编写这样的函数时，可以选择是用数组表示法还是[[C/指针|指针]]表示法。使用数组表示法，让函数是处理数组的这一意图更加明显。
- 另外，许多其他语言的程序员对数组表示法更熟悉。
- 其他程序员可能更习惯使用[[C/指针|指针]]表示法，觉得使用[[C/指针|指针]]更自然。
- 在C语言,`ar[i]` 与 `*(ar + i)` 是等价的。


# [[C/指针|指针]]与多维数组

`int zippo[4][2]; //声明一个二维数组`

- `zippo == &zippo[0] == &zippo[0][0]` 
- `zippo + 1 != zippo[0] + 1 //zippo与zippo[0]数组对应类型的大小不同`
- `*zippo == zippo[0] == &zippo[0][0]` 
- `**zippo == zippo[0][0]`
- 对一个二维数组解引用两次就能得到储存在数组的值。

## 指向多维数组的[[C/指针|指针]]

- 将[[C/指针|指针]]声明为指向数组的指针。
```
int (* pz) [2];           //pz指向一个含两个int值的数组。
int * pax[2];             //定义一个含两个指针的数组pax。

//用圆括号是因为方括号的优先级高于*
```

# 函数与多维数组

- 多维数组的数组名其实就是一个指向数组的指针。
- 一般而言，声明一个指向N维数组的指针时，只能省略最左边方括号中的值:

```
//声明函数形参为指向数组的指针：
void somefunction(int (* pt)[4]);

//当且仅当pt是一个函数的形式参数时也可以这样声明：
void somefunction(int pt[][4]);
//注意，第1个方括号是空的，空的方括号表明pt是一个指针。
```

# 数组与[[C/指针|指针]]的区别
```
char heart[] = "i love Tillie"
const char * head = "i love Millie"
```
- 数组名是常量，而指针名是变量。
- 数组的元素是变量(除非数组被声明为const)，但是数组名不是变量。
- 只有指针表示法可以进行递增操作。递增运算符作用于变量。
- 建议在把指针初始化为字符串字面量时使用const限定符。
- 然而，把非 const 数组初始化为字符串字面量却不会导致类似的问题，因为数组获得的是原始字符串的副本。
- 如果要用数组表示一系列待显示的字符串，请使用指针数组，因为它比二维字符数组的效率高。
- 如果要改变字符串或为字符串输入预留空间，不要使用指向字符串字面量的指针。