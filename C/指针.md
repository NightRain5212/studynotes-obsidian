# 指针

- 指针用于储存变量的地址。[[scanf]][[C/函数]]就使用地址作为参数。
- 指针是一个值为内存地址的变量。
- 指针是一个新类型，不是整数类型。

# 指针声明

- 声明指针变量时必须指定指针所指变量的类型，因为不同变量类型占用不同储存空间。
- 类型说明符表明了指针所指向对象的类型，星号(`*`)表明声明的变量是一个指针。
```
int *pi;         //pi是指向int类型的指针
float *pf,*pg;   //pf和pg是指向float类型的指针
```

# 间接[[运算符]] `*`（解引用运算符）

- `*` 后跟一个指针名或地址时，给出指针指向地址上的值
```
nurse = 22;
ptr = &nurse；//指向nurse的指针
val = *ptr;//把ptr指向的地址上的值赋给val
```
# &[[运算符]]

- &为一元[[运算符]]。
- 若pooh为变量名，则&pooh是变量的地址。
- 可以把地址看作是变量在内存中的位置。

# 打印地址

- %p 是地址的转换说明。
- PC地址通常用十六进制表示，每位十六进制数对应4位。

# 变量交换

```
#include <stdio.h>
void interchange(int * u,int * v);/*声明[[[[函数]]]]*/
int main(void)
{
	int x = 5，y = 10;
	printf("Originally x = %d and y = %d.\n",x,y);
	interchange(x,y);
	printf("Now x = %d and y = %d.\n",x,y);
	return 0;
}
void interchange(int * u ,int * v)/*定义函数 */
{
	int temp;
	temp = *u;
	*u = *v;
	*y = temp;
}
```
- 记住，u的值是&x，所以u指向x。这意味着用`*`u即可表示x的值。
- [[C/函数]]可以调用变量的两类信息
```
function1(x)  
function2(&x)
```

- 如果要计算或处理值，那么使用第1种形式的[[C/函数]]调用:
- 如果要在被调[[C/函数]]中改变主调[[C/函数]]的变量，则使用第2种形式的[[C/函数]]调用。
- 我们用过的[[scanf]]()[[C/函数]]就是这样。当程序要把一个值读入变量时(如本例中的 num)，调用的是 [[scanf]]("%d"，&num)。[[scanf]]()读取一个值，然后把该值储存到指定的地址上。

# 指针操作

- 赋值：把地址赋给指针。
- 解引用：`*` 运算符给出指针指向地址上的值。
- 取址：指针也有自己的地址和值。&ptr可以给出指针所在的地址。
- 指针与整数n相加（减）：地址+/-整数n = 地址+/-指针指向类型大小`*`整数n。
- （得到指向下/上一个数据对象的地址）
- 指针递增(减)：可以让指针移动至[[C/数组]]的下(上)一个元素。
- 指针求差：计算两个指针的差值。计算两元素间的距离。
- （差值单位与数据类型的单位相同）
- 比较：关系运算符比较指针，==前提是指向同一类型==。

#WARNING 不要解引用未初始化的指针！！！

# 保护[[C/数组]]中的数据

- 只有程序需要在函数中改变该数值时，才会传递指针。
- 对于[[C/数组]]，则必须传递指针。

## 对形参用const
```
int sum(const int ar[],int n);
```
- 以上代码中的 const 告诉编译器，该函数不能修改 ar 指向的数组中的内容。
- #WARNING 这样使用const并不是要求原数组是常量,而是该函数在处理数组时将其视为常量。
- 一般而言，如果编写的函数需要修改数组，在声明数组形参时则不使用const；如果编写的函数不用修改数组，那么在声明数组形参时最好使用const。

# const与指针，[[C/数组]]

- const[[C/数组]]：不能改变[[C/数组]]的值。
- 指向const的指针：不能用此指针改变值。`const double * pt;`
- const指针：不能指向别处的指针。`double * const pt;`
- 指向const的指针通常用于函数形参中，表明该函数不会使用指针改变数据
- 把const数据或非const数据的地址赋给指向const的指针是合法的。
- 只能把非const的数据赋给普通指针。
- 因此，对函数的形参使用 const不仅能保护数据，还能让函数处理 const [[C/数组]]。

# 指针的兼容性

- 两个指针指向不同类型无法互相赋值。
- 把 const 指针赋给非 const 指针不安全，因为这样可以使用新的指针改变 const 指针指向的数据。

# 空指针

- 空指针(或 NULL)有一个值，该值不会与任何数据的有效地址对应。通常，函数使用它返回一个有效地址表示某些特殊情况发生，例如遇到文件结尾或未能按预期执行。